Procedural Programming(순차적 프로그래밍)
    Procedure = function

    단점
        호출 스택
        동일한 자료구조 타입을 매개변수로 넘겨줘야 합니다.
        -> 자료구조와 함수가 분리되어 있어서

        struct Stack
        {
            int value;
            Element* pTop;
        };

        void Push(Stack& stack);

Object Oriented Programming (OOP : 객체 지향 프로그래밍)
    -> 자료구조와 함수를 통합
        class Stack
        {
            int value;
            Element* pTop;

            void Push();
        };

Object Oriented Programming
    Object(객체)
    현실 세계의 대상 하나 하나를 객체
        상태(State)
            
        행동(Behaviour)
            
    현실 세계의 오브젝트를 프로그래밍

    Class 와 Instnace
        Class : Object를 상태와 행동으로 만든 추상적인 개념 - 타입
                    상태          행동
            C++     멤버변수        멤버함수
            C#      필드            메서드
            Java    필드            메서드
        Instance : 추상적인 Class를 구체화 시킨 것 - 이름을 붙인 변수
---------------------------------------------------

OOP 5 가지 특징

1. Object
2. Class

3. Encapsulation(캡슐화)
4. Inheritance(상속)
5. Polymorphism(다형성)


캡슐화
    가챠 캡슐 - 내용물을 숨기는 것
    알약 캡슐 - 복용이 쉽다

    정보를 숨김 (Information Hiding)
        사용법을 쉽게

상속
    Inheritance (상속)          Derivation(파생)
    Parent Class (부모 클래스)  Base Class(기반 클래스)
    Child Class (자식 클래스)   Derived Class(파생 클래스)

다형성
    상황에 따라 서로 다른 형태로 해석할 수 있다
    상속과 관련


----------------------------------------------------

class <이름> [: 부모]
{
[접근제한자]
    <멤버>
    .
    .
    .
};

Access Modifier(접근 제한자)
    public
        공개
        클래스 내부(멤버함수)/외부(인스턴스)에서 모두 사용이 가능
    private
        비공개
        클래스 내부(멤버함수)에서만 접근이 가능하고 외부(인스턴스)에서는 불가능

    protected

클래스와 인스턴스

struct Galaxy
{
    int color;
};

int GetColor(Galaxy phone)
{
    return phone.color;
}

Galaxy phone;
GetColor(phone);

class Galaxy
{
public:
    int color;

    int GetColor()
    {
        return color;
    }
};

Galaxy phone1;
phone1.GetColor();

// 암시적 오브젝트(Implicit Object)
// Galaxy* this

컴퓨터 클래스를 만들어 봅시다.

    - 공개 
        가격 - 정수
        색상 - 정수
    - 숨김
        파워 - 정수
        메인보드 - 문자열

    
    - 숨김
        파워표시();
    - 공개
        가격표시();


----------------------------------

클래스의 멤버함수 정의

return-type <class-name>::<member-function>(parameters...)
{

}

::
scope resolution operator

header file
    클래스 선언

cpp file
    클래스 정의(멤버함수)


Class Coding Rule

클래스이름 : 첫글자 대문자 나머지 소문자(PASCAL)
    class Player
    class Bullet
    class DarkElf

멤버변수 : 멤버 m 구문자를 소문자로 명시하고 (Camel)
    int mHealth;
    int mWeight;
    int mHorsePower;

멤버함수 : 첫글자 대문자 나머지 소문자(PASCAL)
    Attack();
    Jump();
    IsDead();

C++ 에서는 구조체는 모든 멤버 변수가 public인 클래스와 동일
    구조체 : 멤버 변수들만 존재
    클래스 : 멤버 변수 + 멤버 함수

캡슐화(Capsulation)
    정보은닉(Information Hiding)
        보안
        사용성

    다른 클래스, 구조체와 같은 타입정보들도 캡슐화

    보안
        

        class Dog
        {
            enum Color
         {
            WHITE = 0xFFFFFF,
            BLACK = 0x101010
         }
            
            Color color;

        };

        class Cat
        {
            enum Color
        {
            WHITE = 0xF0F0F0,
            BLACK = 0x000000
        }

        };

        Dog jhon;
        jhon.color = WHITE;

        Cat nabi;
        nabi.color = BLACK;

Tip) 클래스 선언 정리

    1. 멤버 변수 / 멤버 함수를 구분해서
    class MyClass
    {
    private:
        int x;
    public:
        int y;

    private:
        void f();
    public:
        void g();

    };

    2. 접근 권한으로 구분
    class MyClass
    {
    Private:
        int x;
        void f();

    public:
        int y;
        void g();
    }
    

struct MyStruct
{
    int x;
    int y;
};

class MyClass
{
public:
    int x;
    int y;
};

MyStruct s1;
s1.x =1;

MyClass c1;
c1.x = 1;

Class Computer
{
    int mPrice;
    int mColor;
    int mPower;

public:
    void PrintPower();
    void PrintPrice();
};

Computer my;

my.PrintPower();



const

    constant member function
        this

    상수 변수 - 값을 수정할 수 없음

OOP
    상태 / 행동


    Getter / Setter -> 속성(Property)
        멤버 변수를 숨기고, 접근을 멤버 함수로 수행
            - 내부 값은 숨기고 함수만 노출 안전한 코딩
            - 예외 처리도 가능
            - 가공이 가능


상수 변수
const int LENGTH{10};

상수 매개변수
void Print(const int* x);
{

}

상수 반환값
const int* DoSomething()
{

}

상수 멤버 함수
class MyClass
{
    int GetCount() const;
}

--------------------------------------

int x{1}, y{2};

const int* const p1 = &x;

*p1 = 1;
p1 = &y;

생성자(Constructor) & 소멸자(Destructor)

int myInteger;
myInteger = 1;

// uniform initialization
int myInteger{1};

class MyClass
{

};

생성자
    객체가 인스턴스화될 때 자동적으로 호출되는 특별한 멤버 함수

        - 클래스와 동일한 이름(대소문자 일치)
        - 반환 타입이 없음(void도 없어요)

        MyClass()
        MyClass(int, int)

소멸자
    인스턴스가 소멸될 때 자동적으로 호출되는 특별한 멤버 함수

        - 클래스와 동일한 이름(대소문자 일치)
        - 반환 타입이 없음(void도 없어요)
        - 매개변수도 없음
        - 클래스 이름 앞에 접두어 ~(물결표, tilde)가 붙음

        ~MyClass();

생성자와 소멸자를 만들었느냐

    - 멤버 변수 초기화
    - 기본 작업


기본 생성자(Default Constructor)
    매개변수가 없는 생성자

    Implicit Default Constructor
        생성자를 제공하지 않으면 자동으로 만들어지는 (아무것도 안함)

생성 오버로딩

멤버 초기화 리스트(member initializer list)

    <constructor> : <member-init1>, <member-init2> ...
    {
        [body]
    }






왜 기본생성자가 있느냐!
    POD(Plain Old Data) - C언어 스타일의 데이터 int float double struct {}
        다른 메모리로 혹은 다른 대상(HDD, Network, Graphic...)으로 복사가 쉬움

    그럼 복잡한 데이터 -> C++의 클래스
        암시적 기본생성자가 존재하면 POD
            - 다른 생성자가 없음

    class MyClass
    {
        int* p;

        MyClass()
        {
            p = new int[10000];

            p = (int*)(new Myclass);
        }
    }


컴파일러 이론


int* p1 = new int;
int* p2 = new int;

delete p2;
delete p1;

-------------------------------------------

대리 생성자(Delegate Constructor)

    <constructor> : <other-constructor>
    {

    }

    : 표기를 사용하므로 대리생성자, 멤버 초기화 리스트 중 하나만 사용 가능함


소멸자(Destructor)

    메모리를 해제


class <이름>
{
[접근제한자]:
    [멤버]
    .
    .
};

접근제한자
    - private
    - public

class MyClass
{
public:
    int x;
public:
    void Function();
};

void MyClass::Function()
{
    
}

MyClass c1;
c1.x;
c1.Function();