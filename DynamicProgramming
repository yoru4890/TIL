재귀호출
    트리로 표현하면 이해하기 쉽습니다.
    시간복잡도 : 전체 노드의 갯수
    공간복잡도 : 트리의 높이

BruteForce
    전수조사

Optimize
    중복연산 제거
    문제를 풀고 결과를 저장한다음에 재사용

-----------------------------------------------------

DynamicProgramming ( 동적계획법 )
    memoization(메모화)
        문제의 답을 메모에 적어놓고 재활용
        1. 문제를 푼다 - BruteForce
            a. 문제를 Tree 구조로 표현해 봅니다.
            b. 재귀호출로 구현

        2. Memoization
            a. 공통된 패턴을 찾는다.
            b. 저장하고 재사용 - 메모

        3. 테스트
            a. 1, 2 의 결과가 같아야 합니다.
            b. 1번의 TestCase(입력/출력 에제)를 2번에 적용

    tabulation(테이블화)

=======================================================


⭐Decision Problem
    합을 구할 수 있느냐?

⭐⭐Combination Problem
    조합을 만들어 내는 문제

⭐⭐⭐Optimization Problem
    가장 짧은 배열은?
    모든 경우를 구해봐야 함


=======================================================

피보나치 수열의 40번째 수를 구하세요.
6 x 6 모눈종이를 좌상단에서 우하단으로 이동할 수 있는 경우의 수를 구하세요.
천원을 내면 가격인 720원을 차감하고 잔돈으로 거슬러 줄 최소 동전의 갯수는 몇 개일까요?
커스텀된 사전이 주어질 때, "Hello" 라는 단어를 사전의 단어로 조합할 수 있는 경우는 몇 개일까요?


정수의 배열 numbers에서 숫자들을 조합하여 sum이라는 값을 만들어 낼 수 있는지
확인하는 함수를 만들어 보세요.

제한사항
- numbers는 양수의 집합입니다.
0 <= numbers[i]
- sum을 만들기 위해 동일한 원소를 여러번 사용해도 됩니다.

EX1)
입력 : numbers = {2,3,5}, sum = 8
출력 : true
설명
2 + 3 + 3 = 8 이므로 참입니다.
이외에도 2 + 2 + 2 + 2 역시 8이라서 여러개의 경우의 수가 있을 수 있습니다.

EX2)
입력 : numbers = { 8 , 6}, sum = 7
출력 : false

정수의 배열 numbers에서 숫자들을 조합하여 sum이라는 값을 만들어 낼 수 있는
최적의 조합을 반환하세요. (크기가 최소인 조합)

제한사항
- numbers는 양수의 집합입니다.
0 <= numbers[i]
- sum을 만들기 위해 동일한 원소를 여러번 사용해도 됩니다.

EX1)
입력 : numbers = {2,3,5}, sum = 8
출력 : {3,5}
설명
{2,2,2,2}
{2,3,3}
{3,2,3}
{3,5}
{5,3}
이 중에서 가장 크기가 작은 것 반환

모든 경우의 수 출력)
{
    {2,2,2,2},
    {2,3,3},
    {3,2,3},
    {3,5},
    {5,3}
}


EX2)
입력 : numbers = { 8 , 6}, sum = 7
출력 : nullptr
설명
만들 수 없는 경우는 원소가 없으므로 null을 돌려 줍니다.