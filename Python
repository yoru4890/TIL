Python for C++ programmer

- high-level, general-purpose language
- interpreter language
- dynamically typed
- grabage-collected
- built-in libraries

ëŠë¦¬ë‹¤. í•˜ì§€ë§Œ ê°œë°œì†ë„ëŠ” ë¹ ë¥´ë‹¤

Phthonic



ê¸°ì´ˆë¬¸ë²•

ì´ë¦„ê·œì¹™

- ë³€ìˆ˜ëŠ” ê¸€ì í˜¹ì€ _ë¡œ ì‹œì‘í•´ì•¼í•¨
- ê¸€ìëŠ” A-z, 0-9, _ ë§Œ ì‚¬ìš© ê°€ëŠ¥í•©ë‹ˆë‹¤.
- ëŒ€ì†Œë¬¸ì êµ¬ë¶„

í•¨ìˆ˜ : function, my_function
ë³€ìˆ˜ : variable, my_variable
Class : Bug, MyClass
ìƒìˆ˜ : CONSTANT, MY_CONSTANT
ëª¨ë“ˆ : module.py my_module.py

íŠ¹ìˆ˜í•œ í‘œê¸°
_internal_variable : proteted ë©¤ë²„
__properties : private ë©¤ë²„
special_case_ : keyword ì¤‘ë³µì„ í”¼í•˜ê¸° ìœ„í•´
__magic_word__ : duner(double underscore), ìƒì„±ì, ë¹ŒíŠ¸ì¸ í•¨ìˆ˜


ì½”ë“œë¸”ëŸ­
indent

x = 0
if x > 0:
    print("xëŠ” 0ë³´ë‹¤ í½ë‹ˆë‹¤")


Entry Point ì—†ìŠµë‹ˆë‹¤.
End of line ì—†ìŠµë‹ˆë‹¤.

ì£¼ì„
# í•œì¤„ ì£¼ì„ì…ë‹ˆë‹¤.

x = 1 # ë³€ìˆ˜ xì— 1ì„ ëŒ€ì…í•©ë‹ˆë‹¤.

'''
ì—¬ëŸ¬ì¤„ ì£¼ì„ì…ë‹ˆë‹¤.
'''

"""
ì—¬ëŸ¬ì¤„ ì£¼ì„ì…ë‹ˆë‹¤.
ì—¬ëŸ¬ì¤„ ì£¼ì„ì…ë‹ˆë‹¤.
"""

(ì‚¬ì‹¤ì€ ë¬¸ìì—´ ë¦¬í„°ëŸ´ì´ë‹¤.)

ë³€ìˆ˜
- ì„ ì–¸ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤. ë™ì  íƒ€ì…

x = 0
y = "hello"
z = 3.14

x,y,z = 0, "hello", 3.14

x=0, y="hello", z= 3.14   (ì˜ëª»ë˜ì—ˆë‹¤)

ë¦¬í„°ëŸ´

ì •ìˆ˜ - int - 11, 0xffffffff
ì‹¤ìˆ˜ - float - 3.14 (double ì •ë°€ë„), 1.0e+8
ë³µì†Œìˆ˜ - complex - 1.1 + 2.2j

ë…¼ë¦¬ - bool - True, False
ë¬¸ìì—´ - str - "print"
                char íƒ€ì… X
                null-terminated X
                " ... "
                ' ... '

None - None - nullptr ê°™ì€ ê°œë…

import sys

print(sys.maxsize)

print("Hello World")
print('Hello World')

print('"Hello World"')
print("you aren't my friend")

print(""" '" """)

print(r"c:\test\test")

# íŒŒì´ì¬ì€ ì „ë¶€ ì˜¤ë¸Œì íŠ¸ë‹¤

print(type(1))
print(type(3.14))
print(type("Hello"))
print(type(1.1+2.2j))
print(type(True))
print(type(None))

print("---------------------")

print(int())
print(float())
print(str())


x = 10
y = "cat"

y = x
y = y + 1

print(x)
print(y)

print(f"id: {id(x)} - value: {x}")
print(f"id: {id(y)} - value: {y}")


ì—°ì‚°ì

ì‚°ìˆ ì—°ì‚°ì
+ - * / %

ë¹„êµì—°ì‚°ì

ë…¼ë¦¬ì—°ì‚°ì

# ì—°ì‚°ì
print(1+1)
print(3-2)
print(5*2)
print(6/3)
print(6%3)

print(6//3)
print(2**3)


x = 5
print( 2 < x <= 10)

print(True and False)
print(True or False)
print(not True)

x = y = 1

x, y = 1, 2

x, y = y, x

x += 1
y -= 2
x **= 2

#++x, x++ ì¡´ì¬í•˜ì§€ì•ŠëŠ”ë‹¤

ì‹œí€€ìŠ¤ íƒ€ì…(Sequence Type)

list

set

dict

#list
jobs = ["warrior", "archer", "thief"]

print(jobs[0])
print(jobs[1])

jobs.append("mage")
del jobs[0]

mixed = [1, "ë‘˜", 3 , "Four"]

print(mixed)

array2d = [[1,2,3],[4,5,6],[7,8,9]]
print(array2d)

dynamic_list = [[1],[1,2,3],[1,2,3,4,5]]
print(dynamic_list)

print(mixed[-1])
print([1,2,3] + [4,5,6])
print([1,2,3] * 3)

print(3 in [1,2,3])

# slice
# [start:end:step]
my_list = [1,2,3,4,5]

print(my_list[1:3])
print(my_list[2:])
print(my_list[0:4:2])
print(my_list[::-1])

# str

my_string = "hello world"

print("h" in my_string)
print(my_string[::-1])
print("hello"[0:3])

#format

job = "programmer"
age = 20
name = "John"

print("I am " + job + ".")
print(f"I am {job}, and age is {age}. I am {name}.")

print("ğŸš—")

# tuple - immutable list

x = (1,2)

print(x)

# x[0] = 3 ë¶ˆê°€ëŠ¥

# set

set1 = {1,2,3,4,5}
set1.add(6)

# set1[1] = 0 ë¶ˆê°€ëŠ¥

set2 = {2,4,6,8,10}

print(set1 | set2)
print(set1 & set2)
print(set1 - set2)

print( set1 < set2 )

# dict

developers = {"name" : "Jone", "age" : 30, "country" : "USA", "skills" : ["Java", "C#", "Python"]}

print(developers["name"])

print(developers)

# C++ vs Python
# statement

# if
x = 1
if x > 1:
    print("x > 1")
elif x < 1:
    print("x < 1")
else:
    print("x = 1")

if 1 <= x <= 10:
    print("1 <= x <= 10")


# and, or, not
lane = "bot"
role = "carry"

if lane == "bot" and role == "carry":
    print("ì›ë”œì´ì‹œêµ°ìš”")


# match
operator = "+"

match operator:
    case "+":
        print("Addition")
    case "-":
        print("Subtraction")
    case "and" | "or" | "not":
        print("Logical")
    case _:
        print("Invalid operator")


# while

i = 0
while i < 5:
    print(i)
    i += 1

# for
# C++ì˜ range-based for

champions = ['Lux', 'Ahri', 'Ezreal']
for champion in champions :
    print(champion)

champions = { "name" : "Lux", "type" : "magician"}

for element in champions:
    print(element)

for key, value in champions.items():
    print(key + " : " + value)

for item in champions.items():
    print(item)

for i in range(start, end, step):
    print(i)

# list comprehension
numbers = [1, 2, 3, 4, 5]
for number in numbers:
    if number > 3:
        print(number)

comp = [number*10 for number in numbers if number > 3]
print(comp)

# function

def square(x):
    return x ** 2

def test():
    pass

def test2():
    ...

print(square(5))

def return_many():
    return 1,2,3

print(return_many())

print(type(...))

def create_champion(name, lane="mid"):
    print("Creating" + name + "in" + lane)

create_champion("ahri")

# keyword arguments
create_champion(name="aatrox", lane="top")
create_champion( lane="top",name="aatrox")

f = create_champion

f("Lux", "Mid")

def rotation_champs(func)
    func("Ahri")
    func("Lux")
    func("Zed")

rotation_champs(create_champion)

if 1 == 1:
    if 2 == 2:
        print(2)

for i in range(1,10):
    for j in range(1,10):

def func_1():
    def func_2():
        print("func_2")

    print("func_1")

func_1()
# func_2() ì‚¬ìš©X func_1 ì•ˆì— ìˆë‹¤

# arbitrary arguments

def f(v):
    print(v)

# f(1,2) ë¶ˆê°€
f((1,2))

f({"x":1, "y":2})

def f1(*args):
    for arg in args:
        print(arg)

f1(1,2,3,4)

def f2(**kwargs):
    for key, value in kwargs.items():
        print(key, value)

f2(a=1, b=2, c=3)

# function overloading (í•„ìš”ì—†ë‹¤)

def func(*args):
    pass


# Object Oriented Programming

class Champion:
    # double underscore - dunder - special methods

    # special method
    def __init__(self, name, hp):
        self.name = name        # attribute
        self.hp = hp
        print("Champion created")

    # method
    def move(self):
        print(f"{self.name} moves")

# ahri = Champion()
print(ahri)
print(type(ahri))
print(isinstance(ahri, Champion))
print(isinstance(ahri, object))

struct = { "x": 1, "y": 2}

ahri = Champion("ahri", 100)
print(f"name:{ahri.name}, hp:{ahri.hp}")

ahri.mp = 100
print(ahri.mp)

ahri.move()

class Point2D:
    def __init__(self, x,y):
        self.x = x
        self.y = y

    def __str__(self):
        return f"({self.x},{self.y})"

    def __add__(self, other):
        return Point2D(self.x + other.x, self.y + other.y)

pt1 = Point2D(10,20)
print(pt1)
pt2 = Point2D(30,40)
print(pt1 + pt2)

# public protected private

# public non-public


class Golum:
    def __init__(self):
        pass

    @property # decorator
    def my_precious(self):
        print("getter")
        return self.__my_precious

    @my_precious.setter
    def my_precious(self, value):
        print("setter")
        self.__my_precious = value

g = Golum()
# print(g.__my_precious)
# name mangling
priunt(g._Golum__my_precious)

#FMyFunction
#GVx

g.my_precious = "The Ring"

print(g.my_precious)

attribute - ë©¤ë²„ ë³€ìˆ˜
property - ìº¡ìŠí™”ëœ ë©¤ë²„ ë³€ìˆ˜ì™€ ê²Œí„°/ì„¸í„°

# inheritance
class Animal:
    def __init__(self, name, age):
        self.name = name
        self.age = age
        print("Animal Created")

    def sound(self):
        print("Animal Sound #!@~!@#")

class Cat(Animal):
    def __init__(self, name, age):
        #super().__init__(name,age)
        self.name = name
        self.age = age
        print("Cat Created")

        def sound(self):
            print("Meow")

instance = Animal("kitty", 3)
instance.sound()

instance = Cat("kitty", 3)
instance.sound()
print(instance.name + " " + str(instance.age))

# polymorphism
class Animal:
    def sound(self):
        print("Animal Sound")

class Cat(Animal):
    def sound(self):
        print("Meow")

class Dog(Animal):
    def sound(self):
        print("Bark")

animal = Animal()
cat = Cat()

print(isinstance(cat, Animal))


animals = [Cat(), Dog(), Cat(), Cat(), Dog()]
for animal in animals:
    animal.sound()

x = Cat()
y = Dog()

x, y = y, x

x.sound()
y.sound()

# static variable
# static method vs class method

class MyClass:
    variable = 1

    def func():
        print("This is a message inside the class.")

c = MyClass()
print(c.variable)
print(MyClass.variable) # ì„œë¡œ ë‹¤ë¥´ë‹¤

c1 = MyClass()
c2 = MyClass()
MyClass.variable = 3

c1.variable = 1
c2.variable = 2
print(f"{c1.variable} {c2.variable} {MyClass.variable}")

MyClass.func()

# method vs static method vs class method

class Counter:
    count = 0

    @classmethod
    def increase(cls):
        cls.count += 1
        print(cls.count)

Counter.increase()
Counter.increase()

class Utility:
    @staticmethod
    def sum(x,y):
        return x + y


Utility. sum(1,2)

# module
import math

# maht.py

print(math.sqrt(10))

from math import sqrt

print(sqrt(10))

import random

print(random.randint(1,100))

champions = ["Aatrox", "Ahri", "Akali"]

print(random.choice(champions))
random.shuffle(champions)

import re
import statistics


# 1. ì œ2ì˜ ì–¸ì–´ - ë¹ ë¥¸ ì½”ë”©