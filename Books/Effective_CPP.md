- Chapter 2 생성자, 소멸자 및 대입 연산자
<details>
<summary>항목 12 : 객체의 모든 부분을 빠짐없이 복사하자</summary>

복사 생성자, 복사 대입 연산자 사용시에 직접 만들때는 모든 부분을 복사하도록 하자.

클래스에 변화가 생겼을시에는 그 변화를 복사 생성자, 복사 대입 연산자에 적용시키자.(물론 다른 부분도 마찬가지)

상속시에도 문제가 생긴다. 파생클래스 복사할시 기본클래스의 복사도 잊지 말아야 한다.

추가) 복사 생성자로 복사 대입 연산자를 구현하거나 반대의 경우는 시도하지 말자. 복사 생성자, 복사 대입 연산자의 중복 코드는 따로 함수를 만들어서 관리하자.

</details>

--------
- Chapter 3 자원 관리

<details>
<summary>항목 13 : 자원 관리에는 객체가 그만!</summary>

동적으로 할당시키고 delete로 해제하기보다는 객체를 사용해서 생성자에서 자원획득, 소멸자에서 해제하는 방식으로 설계하자.

좋은 예로 스마트 포인터가 있다.

RAII : Resource Acquisition Is Initialization

자원 획득은 초기화다.

</details>

<details>
<summary>항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자</summary>

RAII 방식의 클래스에서 객체가 복사될때 상황에 맞춰 설계해야한다.

1. 복사금지

말그대로 복사를 허용하지 않는다. 복사가없으니 문제가 일어나지 않는다.

2. 참조 카운터, shared_ptr 사용

기존 클래스의 소멸자가 필요없이 shared_ptr의 삭제자를 사용.

3. 진짜 복사 (깊은 복사)

포인터가 가리키는 대상의 모든 자원을 복사해서 한쪽이 사라져도 다른 한쪽은 사라지지 않도록 해준다.

4. 소유권 이전

before : 원본 -> 자원
after : 사본 -> 자원

자원을 실제로 가리키는 객체를 딱 하나만.

</details>

<details>
<summary>항목 15 : 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자</summary>

자원에 접근해야 하는 경우가 많기에 RAII 클래스에 get()처럼 명시적변환함수를 만들어두자.

경우에 따라서는 암시적변환도 가능하지만 실수가 일어날 수 있다는 것을 인지해야한다.

</details>

<details>
<summary>항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자</summary>

new 표현식에 [] 포함 이면 delete도 [] 포함.

미포함이면 똑같이 미포함


</details>

<details>
<summary>항목 17 : new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자</summary>

```cpp
function(std::shared_ptr<Type>(new Type), function2());
```
위 연산의 실행순서가 컴파일러 제작사마다 다를 수 있다.

new Type -> function2() -> shared_ptr 인 경우 function2()에서 예외상황이 발생하면 누수가 발생한다.

```cpp
std::shared_ptr<Type> p(new Type);

function(p, function2());
```

이렇게 따로 빼주는게 안전하다.

</details>

--------
- Chapter 4 설계 및 선언

<details>
<summary>항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자</summary>

사용자의 실수를 줄이기 위해 타입을 새로 만들고, 그 타입에 대한 연산제한, 값에 대해 제약을 걸어두자.

인터페이스 사이의 일관성을 잡아주고 기본제공 타입과 호환성을 유지하자.

스마트포인터를 사용해서 cross-DLL problem을 방지하자.

사용자의 실수가 컴파일되지 않고, 오류를 알려주자.

</details>

<details>
<summary>항목 19 : 클래스 설계는 타입 설계와 똑같이 취급하자</summary>

- 생성 및 소멸
- 초기화, 대입, 복사
- 가질 수 있는 적법한 값에 대한 제약, 클래스의 불변속성(inveriant)
    - 예를 들어 은행에서 계좌를 관리하는 클래스가 있는데 거기 잔고가 음수일 수 없다는 제약
- 상속 여부 + 가상, 비가상
- 타입변환
- 연산자 처리
- private, protected, public 의 기준, + friend
- 무엇을 선언하지 않을것인가
- 일반적인 경우라면 클래스 템플릿을 생각해야할것이다.
- 꼭 필요한 타입인지? 파생클래스를 만드는것보다 간단한 비멤버함수 or 템플릿이 더 좋을 수도 있다.

</details>

<details>
<summary>항목 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달'방식을 택하는 편이 대개 낫다</summary>

값에 의한 전달은 새로운 객체로 복사해서 전달하기에 대체적으로 느리고 비효율적이다.

왠만한 경우는 상수객체 참조자로 전달하자.


</details>

<details>
<summary>항목 21 : 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자</summary>

연산자 오버로딩에서 쉽게 문제점을 발견할 수 있다.

참조자를 반환, 객체를 반환 결정할때 올바른동작이 이루어지도록 해야한다.


</details>

</details>

<details>
<summary>항목 22 : 데이터 멤버가 선언될 곳은 private 영역임을 명심하자</summary>

일관성있는 접근, public이라면 뒤에 괄호의유무가 바뀐다. 하나로 통일가능

접근에 대해 세밀하게 조정가능, 접근 불가부터 읽기 쓰기 가능 까지

캡슐화로 오히려 수정가능, public인 멤버변수를 수정한다면 끔찍한 일이 벌어진다. '캡슐화가 아니다' 라는 말은 '바꿀 수 없다' 와 동일하다.

protected라고 보호받고 있는것은 아니다. 파생클래스에서 끔찍한 일이 벌어진다.

</details>