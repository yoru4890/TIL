- Chapter 2 생성자, 소멸자 및 대입 연산자
<details>
<summary>항목 12 : 객체의 모든 부분을 빠짐없이 복사하자</summary>

복사 생성자, 복사 대입 연산자 사용시에 직접 만들때는 모든 부분을 복사하도록 하자.

클래스에 변화가 생겼을시에는 그 변화를 복사 생성자, 복사 대입 연산자에 적용시키자.(물론 다른 부분도 마찬가지)

상속시에도 문제가 생긴다. 파생클래스 복사할시 기본클래스의 복사도 잊지 말아야 한다.

추가) 복사 생성자로 복사 대입 연산자를 구현하거나 반대의 경우는 시도하지 말자. 복사 생성자, 복사 대입 연산자의 중복 코드는 따로 함수를 만들어서 관리하자.

</details>

--------
- Chapter 3 자원 관리

<details>
<summary>항목 13 : 자원 관리에는 객체가 그만!</summary>

동적으로 할당시키고 delete로 해제하기보다는 객체를 사용해서 생성자에서 자원획득, 소멸자에서 해제하는 방식으로 설계하자.

좋은 예로 스마트 포인터가 있다.

RAII : Resource Acquisition Is Initialization

자원 획득은 초기화다.

</details>

<details>
<summary>항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자</summary>

RAII 방식의 클래스에서 객체가 복사될때 상황에 맞춰 설계해야한다.

1. 복사금지

말그대로 복사를 허용하지 않는다. 복사가없으니 문제가 일어나지 않는다.

2. 참조 카운터, shared_ptr 사용

기존 클래스의 소멸자가 필요없이 shared_ptr의 삭제자를 사용.

3. 진짜 복사 (깊은 복사)

포인터가 가리키는 대상의 모든 자원을 복사해서 한쪽이 사라져도 다른 한쪽은 사라지지 않도록 해준다.

4. 소유권 이전

before : 원본 -> 자원
after : 사본 -> 자원

자원을 실제로 가리키는 객체를 딱 하나만.

</details>

<details>
<summary>항목 15 : 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자</summary>

자원에 접근해야 하는 경우가 많기에 RAII 클래스에 get()처럼 명시적변환함수를 만들어두자.

경우에 따라서는 암시적변환도 가능하지만 실수가 일어날 수 있다는 것을 인지해야한다.

</details>

<details>
<summary>항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자</summary>

new 표현식에 [] 포함 이면 delete도 [] 포함.

미포함이면 똑같이 미포함


</details>

<details>
<summary>항목 17 : new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자</summary>

```cpp
function(std::shared_ptr<Type>(new Type), function2());
```
위 연산의 실행순서가 컴파일러 제작사마다 다를 수 있다.

new Type -> function2() -> shared_ptr 인 경우 function2()에서 예외상황이 발생하면 누수가 발생한다.

```cpp
std::shared_ptr<Type> p(new Type);

function(p, function2());
```

이렇게 따로 빼주는게 안전하다.

</details>

--------
- Chapter 4 설계 및 선언

<details>
<summary>항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자</summary>

사용자의 실수를 줄이기 위해 타입을 새로 만들고, 그 타입에 대한 연산제한, 값에 대해 제약을 걸어두자.

인터페이스 사이의 일관성을 잡아주고 기본제공 타입과 호환성을 유지하자.

스마트포인터를 사용해서 cross-DLL problem을 방지하자.

사용자의 실수가 컴파일되지 않고, 오류를 알려주자.

</details>

<details>
<summary>항목 19 : 클래스 설계는 타입 설계와 똑같이 취급하자</summary>

- 생성 및 소멸
- 초기화, 대입, 복사
- 가질 수 있는 적법한 값에 대한 제약, 클래스의 불변속성(inveriant)
    - 예를 들어 은행에서 계좌를 관리하는 클래스가 있는데 거기 잔고가 음수일 수 없다는 제약
- 상속 여부 + 가상, 비가상
- 타입변환
- 연산자 처리
- private, protected, public 의 기준, + friend
- 무엇을 선언하지 않을것인가
- 일반적인 경우라면 클래스 템플릿을 생각해야할것이다.
- 꼭 필요한 타입인지? 파생클래스를 만드는것보다 간단한 비멤버함수 or 템플릿이 더 좋을 수도 있다.

</details>

<details>
<summary>항목 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달'방식을 택하는 편이 대개 낫다</summary>

값에 의한 전달은 새로운 객체로 복사해서 전달하기에 대체적으로 느리고 비효율적이다.

왠만한 경우는 상수객체 참조자로 전달하자.


</details>

<details>
<summary>항목 21 : 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자</summary>

연산자 오버로딩에서 쉽게 문제점을 발견할 수 있다.

참조자를 반환, 객체를 반환 결정할때 올바른동작이 이루어지도록 해야한다.


</details>

<details>
<summary>항목 22 : 데이터 멤버가 선언될 곳은 private 영역임을 명심하자</summary>

일관성있는 접근, public이라면 뒤에 괄호의유무가 바뀐다. 하나로 통일가능

접근에 대해 세밀하게 조정가능, 접근 불가부터 읽기 쓰기 가능 까지

캡슐화로 오히려 수정가능, public인 멤버변수를 수정한다면 끔찍한 일이 벌어진다. '캡슐화가 아니다' 라는 말은 '바꿀 수 없다' 와 동일하다.

protected라고 보호받고 있는것은 아니다. 파생클래스에서 끔찍한 일이 벌어진다.

</details>

<details>
<summary>항목 23 : 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자</summary>

멤버 함수보다 오히려 비멤버 비프렌드 함수를 사용하면 캡슐화정도가 높아지고, 유연성, 확장성도 늘어난다.

멤버 함수라면 보여지는 코드가 많아지고 private 멤버 변수의 접근도 올라가기에 캡슐화가 낮아진다.

같은 네임스페이스안에 클래스, 비멤버 비프렌드 함수를 사용하면 좋다.

</details>

<details>
<summary>항목 24 : 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자</summary>

유리수를 나타내는 클래스를 만들고 연산자 오버로딩을 생각해보자

암시적 변환을 위해 explict를 붙이지 않고 int 가 유리수로 바뀌는 생성자를 만들고 operator*를 멤버 함수로 만들면 문제가 생긴다.

교환법칙이 성립안한다. 유리수 * int 는 가능하지만 int * 유리수는 불가능이다. 이유는 첫번째경우는 int가 유리수로 암시적변환이 일어나지만 뒤는 int가 바뀌지 않는다.

int.opeartor*(유리수) 같은 꼴이다. 비멤버 함수로 두어야 가능이다.

주의점) 멤버 함수의 반대는 friend 함수가 아니라 비멤버 함수이다.

</details>

<details>
<summary>항목 25 : 예외를 던지지 않는 swap에 대한 지원도 생각해 보자</summary>

`std::swap`은 복사가 3번 이루어지기에 느리게 작동할 가능성이 있다.(pimpl 구조)

템플릿 특수화 + swap 멤버 함수를 만든다. (포인터가 private이기에 문제가 있다.)

swap 멤버 함수를 호출하는 비멤버 swap 함수를 만든다.

특수화경우 namespace std사용해서 추가하는 방법으로 하지말라. 클래스를 새로운 namespace에 넣어주자. '인자기반탐색(argument-dependent lookup)'규칙으로 같은네임스페이스안에서 특수화버전을 찾아낸다.

함수템플릿안에 swap이 들어가져있는경우에 특수화,일반화를 나누는 방법은 템플릿안에 `using std::swap;`을 사용한다. 먼저 특수화가 되어있는 타입이라면 특수화로 진행하고, 특수화가 되어있지 않은 타입이라면 일반적인 swap이 적용되어진다.

주의점) swap 멤버 함수에서 예외를 던지지 않도록 해야한다.

</details>

--------
- Chapter 5 구현

<details>
<summary>항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자 </summary>

변수 정의는 생성자 1번 , 소멸자 1번이 항상 필요하다.

대입과 초기화를 유심히 관찰해서 쓸데없는 과정을 최대한 줄이도록하자. (기본생성자로 초기화후 대입보다는 바로 초기화시킬 수 있다면 좋을것이다.)

루프의 경우에는 두가지인데 

1. 생성자 1번 + 소멸자 1번 + 대입 n번
2. 생성자 n번 + 소멸자 n번

상황에 따라 다르다. 생성자+소멸자 와 대입을 비교해서 무엇이 더 비용이 많이 드는지 계산하고 판단해야한다.

</details>

<details>
<summary>항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자 </summary>

- 구형(C) 스타일, 신형(C++) 스타일 캐스트가 있는데 신형을 쓰도록 하자.

dynamic_cast 는 런타임에 일어나고 비용이 크다. 왠만한 경우에는 두가지 방법중에 하나를 사용하도록 하자.

1. 타입 안전성을 갖춘 컨테이너 사용 -> 기본 클래스에서 여러 파생클래스로 바꾸지는 못하고 한종류로 사용가능
2. 가상 함수를 기본클래스에 구현 -> 기본클래스에서는 아무 동작 하지 않는다.

</details>

<details>
<summary>항목 28 : 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 되도록 피하자 </summary>

어떤 내부요소에 대한 핸들(참조자, 포인터, 반복자)을 반환하는 것은 되도록 피하자.

캡슐화를 높일수 있고 상수 멤버 함수가 객체의 상수성을 유지한 채로 동작가능하고 무효참조 핸들이 생기는 경우를 최소화할 수 있다. (객체를 달아 줬다가 주소 값만 남기고 사라질 수 있다.)

필요한 경우도 있는데 예외적인 상황으로 operator[] 연산자와 string 또는 vector등의 클래스에 사용되는 경우이다.

</details>

<details>
<summary>항목 29 : 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자! </summary>

예외 안전성을 갖추는 조건으로는 두가지가 있다.

1. 자원이 세지않도록
2. 자료구조를 더럽히지 않도록

예외 안전성 보장에는 3종류가 있다.

1. 기본 보장
2. 강력 보장
3. 예외 금지 보장

강력 보장에는 copy_and_swap 으로 구현가능하지만 모든함수에 강력보장이 되는것은 아니다. copy_and_swap 사이에 작동하는 동작이 강력보장이 아니라면 전체적으로도 강력보장이 아니다.

만약에 어쩔 수 없이 예외 안정성이 보장되어 있지 않게 구현했다면 반드시 문서로 남겨두어야 한다.


</details>

<details>
<summary>항목 30 : 인라인 함수는 미주알고주알 따져서 이해해 두자 </summary>

작고, 자주 호출되는 함수에 대해 인라인 함수를 적용시키자.
디버깅 및 라이브러리의 바이너리 업그레이드가 용이, 코드 부풀림 현상 최소화, 프로그램 속도 향상

함수 템플릿이 헤더 파일에 있다고 해서 인라인함수로 선언하지말자.

우선, 아무것도 인라인하지말도록 하고 꼭 인라인해야 하는 함수 또는 정말 단순한 함수에 한해서만 인라인 함수로 선언하는것부터 시작하자.

</details>

<details>
<summary>항목 31 : 파일 사이의 컴파일 의존성을 최대로 줄이자 </summary>

정의 대신에 선언에 의존하게 하자. 핸들클래스, 인터페이스 클래스

라이브러리 헤더는 그 자체로 모든것을 갖추어야하고, 선언부만 갖고 있어야 한다.

이렇게 하면 실행 시간 비용, 저장 공간이 추가로 늘어나지만 미래를 위해서 좋다. 구현이 바뀌었을때 영향이 적다.

마지막 제품 출시때 비용을 줄일지 고민해도 늦지 않다.

</details>

--------
- Chapter 6 상속, 그리고 객체 지향 설계

<details>
<summary>항목 32 : public 상속 모형은 반드시 "is-a(...는 ...의 일종이다)"를 따르도록 만들자</summary>

A 는 B 이다. 하지만 B 는 A 가 아니다. 이런 형태여야한다.

그런데 단순하게 범위로만 생각해서는 안된다.

정사각형은 직사각형이다. 하지만 정사각형은 직사각형이 아니다. 맞는말이다. 그렇지만 이 둘을 상속으로 한다면 조심해야 할것이다.

직사각형은 한변만 길이를 줄이거나 늘릴수 있는데 정사각형은 한변만 조정이 불가능하다. 따라서 직사각형으로부터 파생시킨다면 저 기능을 없애거나 파생시키면 안된다.


</details>

<details>
<summary>항목 33 : 상속된 이름을 숨기는 일은 피하자</summary>

파생 클래스의 이름은 기본 클래스의 이름을 가리는데 public 상속에서는 좋지 않은 현상.

파생 클래스에서 using 기본 클래스를 선언해서 알 수 있게 하자.

만약 부분적으로 기능을 받고 싶다면 private 상속으로 하고, 부분 기능을 전달함수로 구현하자.

</details>

<details>
<summary>항목 34 : 인터페이스 상속과 구현 상속의 차이를 제대로 파악하고 구별하자</summary>

세가지 경우가 있고 각각의 경우에 따라 목적이 다르다.

1. 순수 가상 함수

    인터페이스 상속만

    이 기능이 파생 클래스에는 필요하지만 구현은 각각 파생 클래스마다 해라.

2. 단순(비순수) 가상 함수

    인터페이스 상속 + 기본 구현 상속

    공통된 기본 구현은 기본 클래스에서 했고, 필요하면 파생 클래스에서 사용해라.

    주의점이 있다. 새로 추가된 파생클래스가 지금까지와는 다른 기본 구현이 되어있는 경우에는 설계가 틀어지게 된다. 두가지 해결 방법이 있다.

    첫번째, 순수 가상 함수로 바꾸고 기본 구현은 protected로 비가상 함수로 구현해준다. 이렇게 설계하면 파생 클래스마다 비가상 함수를 사용유무를 선택할 수 있다.

    두번째, 순수 가상 함수로 바꾸고, 순수 가상 함수를 구현하는 것이다. 위의 설계와 비슷하지만 큰 차이점은 보호 수준이 달라졌다는 점이다. 위는 protected로 되어있고 이 경우는 public으로 되어 있다.

3. 비가상 함수

    인터페이스 상속 + 필수 구현 상속

    어떤 파생 클래스여도 절대 변하지 않는 기능이다.

</details>

<details>
<summary>항목 35 : 가상 함수 대신 쓸 것들도 생각해 두는 자세를 시시때때로 길러 두자</summary>

가상 함수 이외의 방법으로 설계하는 방법도 있다. NVI 관용구 및 전략(Strategy) 패턴 등등

NVI(non-virtual-interface) 비가상함수를 가상함수를 싸서 사용한다.

사전동작 -> 실제 동작(가상함수) -> 사후동작

비가상함수는 시기(when)을 조정할 수 있고 가상함수는 동작(how)을 조정할 수 있다.
여기서 비가상함수는 가상함수의 랩퍼(wrapper)

전력패턴은 여러가지가 있다.

함수 포인터로 구현방법, tr1::function으로 구현방법, 클래스를 새로 만들어서 관리하는 방법


</details>

<details>
<summary>항목 36 : 상속받은 비가상 함수를 파생 클래스에서 재정의하는 것은 절대 금물!</summary>

객체 지향 설계에서 파생된 클래스는 기본 클래스의 모든 기능들을 가진다. 비가상 함수인 경우 기본 클래스의 함수가 지워지기에 기능이 서로 다른경우라면 옳지 않다.

파생클래스에서 기능이 달라지는 경우 비가상 함수말고 가상 함수로 해야한다.

</details>

<details>
<summary>항목 37 : 어떤 함수에 대해서도 상속받은 기본 매개변수 값은 절대로 재정의하지 말자</summary>

기본 클래스와 파생클래스에 기본 매개변수를 설정했을 경우, 파생클래스에서 함수를 기본으로 호출시 기본클래스의 기본매개변수를 사용할 수 있다.

그렇다고 기본 클래스와 파생 클래스를 통일 시키면 코드중복이 일어나고 또한, 변경이 일어났을때 전부 바꿔줘야 하는 번거러움이 생긴다.

NVI 관용구를 사용하면 해결

위의 현상이 일어나는 이유는 기본 매개변수값은 정적바인딩이고 가상함수는 동적바인딩이기 때문이다.

</details>

<details>
<summary>항목 38 : "has-a(...는...를 가짐)" 혹은 "is-implemented-in-terms-of(...는...를 써서 구현됨)"를 모형화할 때는 객체 합성을 사용하자 </summary>

객체 합성은 객체가 또 다른 객체를 멤버로 가지는 것이다.

"has-a" 는 사물을 본 뜬 것들, "is-implemented-in-terms-of"는 시스템적인 구현을 위한 인공물

</details>

<details>
<summary>항목 39 : private 상속은 심사숙고해서 구사하자</summary>

private 상속은 "is-implemented-in-terms-of"이다.

"is-implemented-in-terms-of" 를 객체 합성과 private 상속 둘중에 하나를 골라서 사용해야 하는데 할 수 있으면 객체 합성, 꼭 해야하면 private 상속으로 해라.

객체 합성으로 하면 좋은점, 새로 파생 클래스를 만들때 다시 재정의 하는 것을 막을 수 있다. 컴파일 의존성을 최소화 할 수 있다.

private 상속은 protected 멤버에 접근 또는 상속받은 가상함수를 재정의해야 할경우, 공백 기본 클래스 최적화(EBO : Empty Base Optimization)를 활성가능

</details>

<details>
<summary>항목 40 : 다중 상속은 심사숙고해서 사용하자</summary>

다중 상속은 단일 상속보다 복잡하고, 모호성 문제가 생길 수 있고 가상 상속이 필요해질수 있다.(가상 상속은 비용이 크다)

다중상속의 좋은 예 : 인터페이스 클래스로부터 public 상속, 구현을 돕는 클래스로부터 private 상속

</details>

--------
- Chapter 7 템플릿과 일반화 프로그래밍

<details>
<summary>항목 41 : 템플릿 프로그래밍의 천릿길도 암시적 인터페이스와 컴파일 타임 다형성부터</summary>

클래스 및 템플릿 모두 인터페이스와 다형성을 지원한다.

클래스의 경우, 인터페이스가 명시적이고 함수의 시그니처 중심, 다형성은 가상함수를 통해 동적으로 일어난다.

템플릿의 경우, 인터페이스가 암시적이고 유효 표현식에 기반, 다형성은 컴파일 중에 템플릿 인스턴스화와 함수 오버로딩 모호성 해결을 통해 나타난다.

</details>

<details>
<summary>항목 42 : typename의 두 가지 의미를 제대로 파악하자 </summary>

템플릿에서 typename은 class라고 써도 상관없다.

중첩 의존 타입 이름을 식별하기 위해 typename을 사용하자.
(예외 : 기본 클래스 리스트에 있거나 멤버 초기화 리스트안에 기본 클래스 식별자로 있는 경우)

</details>

<details>
<summary>항목 43 : 템플릿으로 만들어진 기본 클래스 안의 이름에 접근하는 방법을 알아 두자 </summary>

특수화 템플릿이 존재할 수 있어서 C++ 컴파일러는 템플릿에서 기본 클래스를 뒤져서 상속된 이름을 찾지 않는다.

this나 using으로 기본클래스의 존재를 알려준다.

</details>

<details>
<summary>항목 44 : 매개변수에 독립적인 코드는 템플릿으로부터 분리시키자 </summary>

매개변수에 종속되지 않은 템플릿 코드는 비대화의 원인이다.

비타임 템플릿 매개변수가 원인인 경우, 함수 매개변수 or 클래스 데이터 멤버로 대체하자.

타입 매개변수가 원인인 경우, 동일한 이진 표현구조의 타입들을 한 가지 함수 구현을 공유하게 하자.

</details>

<details>
<summary>항목 45 : "호환되는 모든 타입"을 받아들이는 데는 멤버 함수 템플릿이 직방! </summary>

호환되는 모든 타입을 받아들이는 멤버 함수를 만들려면 멤버 함수 템플릿을 사용하자.

일반화된 복사생성 연산과 대입 연산을 위해 멤버 템플릿을 선언했어도, 보통의 복사 생성자와 복사 대입 연산자는 여전히 직접 선언해야한다.

</details>

<details>
<summary>항목 46 : 타입 변환이 바람직할 경우에는 비멤버 함수를 클래스 템플릿 안에 정의해 두자 </summary>

템플릿 인자 추론 문제 발생

모든 매개변수에 대해 암시적 타입 변환을 지원하는 템플릿과 관계가 있는 함수를 제공하는 클래스 템플릿의 경우, 함수를 클래스 템플릿 안에 프렌드 함수로 정의하자.

</details>

<details>
<summary>항목 47 : 타입에 대한 정보가 필요하다면 특성정보 클래스를 사용하자 </summary>

특성정보 클래스는 컴파일 도중에 사용할 수 있는 타입 관련 정보를 만들어내고, 템플릿 및 템플릿 특수화를 사용하여 구현한다.

특성정보 클래스는 런타임이 아닌 컴파일 시간에 오버로딩 기법을 결합하여 체크 할 수 있다. 

</details>

<details>
<summary>항목 48 : 템플릿 메타프로그래밍, 하지 않겠는가? </summary>

TMP는 런타임에서의 작업을 컴파일 타임으로 바꿀 수 있다.

에러를 먼저 찾을 수 있고 런타임효율이 높아진다.

policy-based design에 기반하여 사용자 정의 코드를 만들 수 있고, 특정 타입에 대해 부적절한 코드가 만들어지는 것을 막을 수 있다.

</details>

--------
- Chapter 8 new와 delete를 내 맘대로

<details>
<summary>항목 49 : new 처리자의 동작 원리를 제대로 이해하자</summary>

set_new_handler 함수를 쓰면 메모리 할당 요청이 만족되지 못했을 때 호출되는 함수를 지정할 수 있다.

예외불가 new는 영향력이 제한되어 있다. 메모리 할당 자체에만 적용되기 때문. 이후에 호출되는 생성자에서는 얼마든지 예외를 던질 수 있다.


</details>