- Chapter 2 생성자, 소멸자 및 대입 연산자
<details>
<summary>항목 12 : 객체의 모든 부분을 빠짐없이 복사하자</summary>

복사 생성자, 복사 대입 연산자 사용시에 직접 만들때는 모든 부분을 복사하도록 하자.

클래스에 변화가 생겼을시에는 그 변화를 복사 생성자, 복사 대입 연산자에 적용시키자.(물론 다른 부분도 마찬가지)

상속시에도 문제가 생긴다. 파생클래스 복사할시 기본클래스의 복사도 잊지 말아야 한다.

추가) 복사 생성자로 복사 대입 연산자를 구현하거나 반대의 경우는 시도하지 말자. 복사 생성자, 복사 대입 연산자의 중복 코드는 따로 함수를 만들어서 관리하자.

</details>

--------
- Chapter 3 자원 관리

<details>
<summary>항목 13 : 자원 관리에는 객체가 그만!</summary>

동적으로 할당시키고 delete로 해제하기보다는 객체를 사용해서 생성자에서 자원획득, 소멸자에서 해제하는 방식으로 설계하자.

좋은 예로 스마트 포인터가 있다.

RAII : Resource Acquisition Is Initialization

자원 획득은 초기화다.

</details>

<details>
<summary>항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자</summary>

RAII 방식의 클래스에서 객체가 복사될때 상황에 맞춰 설계해야한다.

1. 복사금지

말그대로 복사를 허용하지 않는다. 복사가없으니 문제가 일어나지 않는다.

2. 참조 카운터, shared_ptr 사용

기존 클래스의 소멸자가 필요없이 shared_ptr의 삭제자를 사용.

3. 진짜 복사 (깊은 복사)

포인터가 가리키는 대상의 모든 자원을 복사해서 한쪽이 사라져도 다른 한쪽은 사라지지 않도록 해준다.

4. 소유권 이전

before : 원본 -> 자원
after : 사본 -> 자원

자원을 실제로 가리키는 객체를 딱 하나만.

</details>

<details>
<summary>항목 15 : 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자</summary>

자원에 접근해야 하는 경우가 많기에 RAII 클래스에 get()처럼 명시적변환함수를 만들어두자.

경우에 따라서는 암시적변환도 가능하지만 실수가 일어날 수 있다는 것을 인지해야한다.

</details>

<details>
<summary>항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자</summary>

new 표현식에 [] 포함 이면 delete도 [] 포함.

미포함이면 똑같이 미포함


</details>

<details>
<summary>항목 17 : new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자</summary>

```cpp
function(std::shared_ptr<Type>(new Type), function2());
```
위 연산의 실행순서가 컴파일러 제작사마다 다를 수 있다.

new Type -> function2() -> shared_ptr 인 경우 function2()에서 예외상황이 발생하면 누수가 발생한다.

```cpp
std::shared_ptr<Type> p(new Type);

function(p, function2());
```

이렇게 따로 빼주는게 안전하다.

</details>

--------
- Chapter 4 설계 및 선언

<details>
<summary>항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자</summary>

사용자의 실수를 줄이기 위해 타입을 새로 만들고, 그 타입에 대한 연산제한, 값에 대해 제약을 걸어두자.

인터페이스 사이의 일관성을 잡아주고 기본제공 타입과 호환성을 유지하자.

스마트포인터를 사용해서 cross-DLL problem을 방지하자.

사용자의 실수가 컴파일되지 않고, 오류를 알려주자.

</details>