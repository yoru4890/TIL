- Chapter 2 생성자, 소멸자 및 대입 연산자
<details>
<summary>항목 12 : 객체의 모든 부분을 빠짐없이 복사하자</summary>

복사 생성자, 복사 대입 연산자 사용시에 직접 만들때는 모든 부분을 복사하도록 하자.

클래스에 변화가 생겼을시에는 그 변화를 복사 생성자, 복사 대입 연산자에 적용시키자.(물론 다른 부분도 마찬가지)

상속시에도 문제가 생긴다. 파생클래스 복사할시 기본클래스의 복사도 잊지 말아야 한다.

추가) 복사 생성자로 복사 대입 연산자를 구현하거나 반대의 경우는 시도하지 말자. 복사 생성자, 복사 대입 연산자의 중복 코드는 따로 함수를 만들어서 관리하자.

</details>

--------
- Chapter 3 자원 관리

<details>
<summary>항목 13 : 자원 관리에는 객체가 그만!</summary>

동적으로 할당시키고 delete로 해제하기보다는 객체를 사용해서 생성자에서 자원획득, 소멸자에서 해제하는 방식으로 설계하자.

좋은 예로 스마트 포인터가 있다.

RAII : Resource Acquisition Is Initialization

자원 획득은 초기화다.

</details>

<details>
<summary>항목 14 : 자원 관리 클래스의 복사 동작에 대해 진지하게 고찰하자</summary>

RAII 방식의 클래스에서 객체가 복사될때 상황에 맞춰 설계해야한다.

1. 복사금지

말그대로 복사를 허용하지 않는다. 복사가없으니 문제가 일어나지 않는다.

2. 참조 카운터, shared_ptr 사용

기존 클래스의 소멸자가 필요없이 shared_ptr의 삭제자를 사용.

3. 진짜 복사 (깊은 복사)

포인터가 가리키는 대상의 모든 자원을 복사해서 한쪽이 사라져도 다른 한쪽은 사라지지 않도록 해준다.

4. 소유권 이전

before : 원본 -> 자원
after : 사본 -> 자원

자원을 실제로 가리키는 객체를 딱 하나만.

</details>

<details>
<summary>항목 15 : 자원 관리 클래스에서 관리되는 자원은 외부에서 접근할 수 있도록 하자</summary>

자원에 접근해야 하는 경우가 많기에 RAII 클래스에 get()처럼 명시적변환함수를 만들어두자.

경우에 따라서는 암시적변환도 가능하지만 실수가 일어날 수 있다는 것을 인지해야한다.

</details>

<details>
<summary>항목 16 : new 및 delete를 사용할 때는 형태를 반드시 맞추자</summary>

new 표현식에 [] 포함 이면 delete도 [] 포함.

미포함이면 똑같이 미포함


</details>

<details>
<summary>항목 17 : new로 생성한 객체를 스마트 포인터에 저장하는 코드는 별도의 한 문장으로 만들자</summary>

```cpp
function(std::shared_ptr<Type>(new Type), function2());
```
위 연산의 실행순서가 컴파일러 제작사마다 다를 수 있다.

new Type -> function2() -> shared_ptr 인 경우 function2()에서 예외상황이 발생하면 누수가 발생한다.

```cpp
std::shared_ptr<Type> p(new Type);

function(p, function2());
```

이렇게 따로 빼주는게 안전하다.

</details>

--------
- Chapter 4 설계 및 선언

<details>
<summary>항목 18 : 인터페이스 설계는 제대로 쓰기엔 쉽게, 엉터리로 쓰기엔 어렵게 하자</summary>

사용자의 실수를 줄이기 위해 타입을 새로 만들고, 그 타입에 대한 연산제한, 값에 대해 제약을 걸어두자.

인터페이스 사이의 일관성을 잡아주고 기본제공 타입과 호환성을 유지하자.

스마트포인터를 사용해서 cross-DLL problem을 방지하자.

사용자의 실수가 컴파일되지 않고, 오류를 알려주자.

</details>

<details>
<summary>항목 19 : 클래스 설계는 타입 설계와 똑같이 취급하자</summary>

- 생성 및 소멸
- 초기화, 대입, 복사
- 가질 수 있는 적법한 값에 대한 제약, 클래스의 불변속성(inveriant)
    - 예를 들어 은행에서 계좌를 관리하는 클래스가 있는데 거기 잔고가 음수일 수 없다는 제약
- 상속 여부 + 가상, 비가상
- 타입변환
- 연산자 처리
- private, protected, public 의 기준, + friend
- 무엇을 선언하지 않을것인가
- 일반적인 경우라면 클래스 템플릿을 생각해야할것이다.
- 꼭 필요한 타입인지? 파생클래스를 만드는것보다 간단한 비멤버함수 or 템플릿이 더 좋을 수도 있다.

</details>

<details>
<summary>항목 20 : '값에 의한 전달'보다는 '상수객체 참조자에 의한 전달'방식을 택하는 편이 대개 낫다</summary>

값에 의한 전달은 새로운 객체로 복사해서 전달하기에 대체적으로 느리고 비효율적이다.

왠만한 경우는 상수객체 참조자로 전달하자.


</details>

<details>
<summary>항목 21 : 함수에서 객체를 반환해야 할 경우에 참조자를 반환하려고 들지 말자</summary>

연산자 오버로딩에서 쉽게 문제점을 발견할 수 있다.

참조자를 반환, 객체를 반환 결정할때 올바른동작이 이루어지도록 해야한다.


</details>

<details>
<summary>항목 22 : 데이터 멤버가 선언될 곳은 private 영역임을 명심하자</summary>

일관성있는 접근, public이라면 뒤에 괄호의유무가 바뀐다. 하나로 통일가능

접근에 대해 세밀하게 조정가능, 접근 불가부터 읽기 쓰기 가능 까지

캡슐화로 오히려 수정가능, public인 멤버변수를 수정한다면 끔찍한 일이 벌어진다. '캡슐화가 아니다' 라는 말은 '바꿀 수 없다' 와 동일하다.

protected라고 보호받고 있는것은 아니다. 파생클래스에서 끔찍한 일이 벌어진다.

</details>

<details>
<summary>항목 23 : 멤버 함수보다는 비멤버 비프렌드 함수와 더 가까워지자</summary>

멤버 함수보다 오히려 비멤버 비프렌드 함수를 사용하면 캡슐화정도가 높아지고, 유연성, 확장성도 늘어난다.

멤버 함수라면 보여지는 코드가 많아지고 private 멤버 변수의 접근도 올라가기에 캡슐화가 낮아진다.

같은 네임스페이스안에 클래스, 비멤버 비프렌드 함수를 사용하면 좋다.

</details>

<details>
<summary>항목 24 : 타입 변환이 모든 매개변수에 대해 적용되어야 한다면 비멤버 함수를 선언하자</summary>

유리수를 나타내는 클래스를 만들고 연산자 오버로딩을 생각해보자

암시적 변환을 위해 explict를 붙이지 않고 int 가 유리수로 바뀌는 생성자를 만들고 operator*를 멤버 함수로 만들면 문제가 생긴다.

교환법칙이 성립안한다. 유리수 * int 는 가능하지만 int * 유리수는 불가능이다. 이유는 첫번째경우는 int가 유리수로 암시적변환이 일어나지만 뒤는 int가 바뀌지 않는다.

int.opeartor*(유리수) 같은 꼴이다. 비멤버 함수로 두어야 가능이다.

주의점) 멤버 함수의 반대는 friend 함수가 아니라 비멤버 함수이다.

</details>

<details>
<summary>항목 25 : 예외를 던지지 않는 swap에 대한 지원도 생각해 보자</summary>

`std::swap`은 복사가 3번 이루어지기에 느리게 작동할 가능성이 있다.(pimpl 구조)

템플릿 특수화 + swap 멤버 함수를 만든다. (포인터가 private이기에 문제가 있다.)

swap 멤버 함수를 호출하는 비멤버 swap 함수를 만든다.

특수화경우 namespace std사용해서 추가하는 방법으로 하지말라. 클래스를 새로운 namespace에 넣어주자. '인자기반탐색(argument-dependent lookup)'규칙으로 같은네임스페이스안에서 특수화버전을 찾아낸다.

함수템플릿안에 swap이 들어가져있는경우에 특수화,일반화를 나누는 방법은 템플릿안에 `using std::swap;`을 사용한다. 먼저 특수화가 되어있는 타입이라면 특수화로 진행하고, 특수화가 되어있지 않은 타입이라면 일반적인 swap이 적용되어진다.

주의점) swap 멤버 함수에서 예외를 던지지 않도록 해야한다.

</details>

--------
- Chapter 5 구현

<details>
<summary>항목 26 : 변수 정의는 늦출 수 있는 데까지 늦추는 근성을 발휘하자 </summary>

변수 정의는 생성자 1번 , 소멸자 1번이 항상 필요하다.

대입과 초기화를 유심히 관찰해서 쓸데없는 과정을 최대한 줄이도록하자. (기본생성자로 초기화후 대입보다는 바로 초기화시킬 수 있다면 좋을것이다.)

루프의 경우에는 두가지인데 

1. 생성자 1번 + 소멸자 1번 + 대입 n번
2. 생성자 n번 + 소멸자 n번

상황에 따라 다르다. 생성자+소멸자 와 대입을 비교해서 무엇이 더 비용이 많이 드는지 계산하고 판단해야한다.

</details>

<details>
<summary>항목 27 : 캐스팅은 절약, 또 절약! 잊지 말자 </summary>

- 구형(C) 스타일, 신형(C++) 스타일 캐스트가 있는데 신형을 쓰도록 하자.

dynamic_cast 는 런타임에 일어나고 비용이 크다. 왠만한 경우에는 두가지 방법중에 하나를 사용하도록 하자.

1. 타입 안전성을 갖춘 컨테이너 사용 -> 기본 클래스에서 여러 파생클래스로 바꾸지는 못하고 한종류로 사용가능
2. 가상 함수를 기본클래스에 구현 -> 기본클래스에서는 아무 동작 하지 않는다.

</details>

<details>
<summary>항목 28 : 내부에서 사용하는 객체에 대한 '핸들'을 반환하는 코드는 되도록 피하자 </summary>

어떤 내부요소에 대한 핸들(참조자, 포인터, 반복자)을 반환하는 것은 되도록 피하자.

캡슐화를 높일수 있고 상수 멤버 함수가 객체의 상수성을 유지한 채로 동작가능하고 무효참조 핸들이 생기는 경우를 최소화할 수 있다. (객체를 달아 줬다가 주소 값만 남기고 사라질 수 있다.)

필요한 경우도 있는데 예외적인 상황으로 operator[] 연산자와 string 또는 vector등의 클래스에 사용되는 경우이다.

</details>

<details>
<summary>항목 29 : 예외 안전성이 확보되는 그날 위해 싸우고 또 싸우자! </summary>

예외 안전성을 갖추는 조건으로는 두가지가 있다.

1. 자원이 세지않도록
2. 자료구조를 더럽히지 않도록

예외 안전성 보장에는 3종류가 있다.

1. 기본 보장
2. 강력 보장
3. 예외 금지 보장

강력 보장에는 copy_and_swap 으로 구현가능하지만 모든함수에 강력보장이 되는것은 아니다. copy_and_swap 사이에 작동하는 동작이 강력보장이 아니라면 전체적으로도 강력보장이 아니다.

만약에 어쩔 수 없이 예외 안정성이 보장되어 있지 않게 구현했다면 반드시 문서로 남겨두어야 한다.


</details>

<details>
<summary>항목 30 : 인라인 함수는 미주알고주알 따져서 이해해 두자 </summary>

작고, 자주 호출되는 함수에 대해 인라인 함수를 적용시키자.
디버깅 및 라이브러리의 바이너리 업그레이드가 용이, 코드 부풀림 현상 최소화, 프로그램 속도 향상

함수 템플릿이 헤더 파일에 있다고 해서 인라인함수로 선언하지말자.

우선, 아무것도 인라인하지말도록 하고 꼭 인라인해야 하는 함수 또는 정말 단순한 함수에 한해서만 인라인 함수로 선언하는것부터 시작하자.

</details>

<details>
<summary>항목 31 : 파일 사이의 컴파일 의존성을 최대로 줄이자 </summary>

정의 대신에 선언에 의존하게 하자. 핸들클래스, 인터페이스 클래스

라이브러리 헤더는 그 자체로 모든것을 갖추어야하고, 선언부만 갖고 있어야 한다.

이렇게 하면 실행 시간 비용, 저장 공간이 추가로 늘어나지만 미래를 위해서 좋다. 구현이 바뀌었을때 영향이 적다.

마지막 제품 출시때 비용을 줄일지 고민해도 늦지 않다.

</details>

--------
- Chapter 6 상속, 그리고 객체 지향 설계

<details>
<summary>항목 32 : public 상속 모형은 반드시 "is-a(...는 ...의 일종이다)"를 따르도록 만들자</summary>

A 는 B 이다. 하지만 B 는 A 가 아니다. 이런 형태여야한다.

그런데 단순하게 범위로만 생각해서는 안된다.

정사각형은 직사각형이다. 하지만 정사각형은 직사각형이 아니다. 맞는말이다. 그렇지만 이 둘을 상속으로 한다면 조심해야 할것이다.

직사각형은 한변만 길이를 줄이거나 늘릴수 있는데 정사각형은 한변만 조정이 불가능하다. 따라서 직사각형으로부터 파생시킨다면 저 기능을 없애거나 파생시키면 안된다.


</details>

<details>
<summary>항목 33 : 상속된 이름을 숨기는 일은 피하자</summary>

파생 클래스의 이름은 기본 클래스의 이름을 가리는데 public 상속에서는 좋지 않은 현상.

파생 클래스에서 using 기본 클래스를 선언해서 알 수 있게 하자.

만약 부분적으로 기능을 받고 싶다면 private 상속으로 하고, 부분 기능을 전달함수로 구현하자.


</details>
